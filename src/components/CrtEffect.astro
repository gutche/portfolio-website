---
// Props for the component
const { isMobile = false, class: className } = Astro.props;
---

<div
	class={`${isMobile ? "crt-container-mobile" : "crt-container"} ${className || ""}`}
	data-image-url={Astro.props.imageUrl}>
</div>

<script>
	import * as THREE from "three";

	class CRTEffect {
		container: HTMLElement;
		width: number;
		height: number;
		scene: THREE.Scene = new THREE.Scene();
		camera: THREE.OrthographicCamera = new THREE.OrthographicCamera();
		renderer: THREE.WebGLRenderer = new THREE.WebGLRenderer();
		material: THREE.ShaderMaterial = new THREE.ShaderMaterial();

		constructor(container: HTMLElement) {
			this.container = container;
			this.width = container.clientWidth;
			this.height = container.clientHeight;
			this.setupScene();
			
			// Load the image before animation
			const imageUrl = container.getAttribute('data-image-url');
			if (imageUrl) {
				const loader = new THREE.TextureLoader();
				loader.load(imageUrl, (texture) => {
					// Set texture wrapping and repeat to avoid stretching
					texture.wrapS = THREE.ClampToEdgeWrapping;
					texture.wrapT = THREE.ClampToEdgeWrapping;
					this.material.uniforms.tDiffuse = { value: texture };
					this.animate();
					// Trigger initial resize to ensure proper fitting
					this.updateSize();
				});
			} else {
				this.animate();
			}
			
			this.setupResizeListener();
		}

		setupScene() {
			this.scene = new THREE.Scene();
			this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
			this.camera.position.z = 1;

			this.renderer = new THREE.WebGLRenderer({
				antialias: false,
				alpha: true,
				premultipliedAlpha: false,
			});
			this.renderer.setSize(this.width, this.height);
			this.renderer.setPixelRatio(window.devicePixelRatio);
			this.renderer.setClearColor(0x000000, 0);
			this.container.appendChild(this.renderer.domElement);

			const geometry = new THREE.PlaneGeometry(2, 2);

			// Modified shader material to create CRT effects with improved brightness and moving scan lines
			this.material = new THREE.ShaderMaterial({
				uniforms: {
					tDiffuse: { value: null }, // Texture will be set after loading
					time: { value: 0.0 },
					sIntensity: { value: 0.08 }, // Reduced for subtler scan lines
					sCount: { value: 800 }, // More lines for smoother effect
					nIntensity: { value: 0.15 }, // Adjusted noise
					brightness: { value: 1.0 }, // Normal brightness
				},
				transparent: true,
				vertexShader: `
				varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
				}
				`,
				fragmentShader: `
				uniform sampler2D tDiffuse;
				uniform float time;
				uniform float sIntensity;
				uniform float sCount;
				uniform float nIntensity;
				uniform float brightness;
				varying vec2 vUv;

				float random(vec2 c) {
					return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);
				}

				void main() {
					vec2 uv = vUv;
					
					// Get the original texture color
					vec4 texel = texture2D(tDiffuse, uv);
					
					// Create moving scanline effect (top to bottom) - slower speed
					float scanline = 0.5 + 0.5 * sin(uv.y * sCount - time * 0.8);
					scanline = 1.0 - (scanline * sIntensity);
					
					// Create noise effect
					float noise = random(uv + vec2(time * 0.001)) * nIntensity;
					
					// Apply effects while preserving original colors
					vec3 result = texel.rgb * scanline * brightness;
					result += vec3(noise) * 0.15;
					
					gl_FragColor = vec4(result, texel.a);
				}
				`,
			});

			const plane = new THREE.Mesh(geometry, this.material);
			this.scene.add(plane);
			this.container.classList.add("loaded");
		}

		animate() {
			requestAnimationFrame(this.animate.bind(this));
			this.material.uniforms.time.value = performance.now() / 1000;
			this.renderer.render(this.scene, this.camera);
		}
		
		updateSize() {
			// Get current dimensions
			const containerRect = this.container.getBoundingClientRect();
			this.width = containerRect.width - 100;
			this.height = containerRect.height- 100;
			
			// Update renderer size
			this.renderer.setSize(this.width, this.height);
			
			// Calculate aspect ratio
			const aspect = this.width / this.height;
			// Update camera to maintain proper aspect ratio
			this.camera.left = -1 * aspect;
			this.camera.right = 1 * aspect;
			this.camera.updateProjectionMatrix();
		}

		setupResizeListener() {
			// Use ResizeObserver for more accurate size tracking
			if (typeof ResizeObserver !== 'undefined') {
				const resizeObserver = new ResizeObserver(() => {
					this.updateSize();
				});
				resizeObserver.observe(this.container);
			} else {
				// Fallback to window resize event
				window.addEventListener("resize", () => {
					this.updateSize();
				});
			}
		}
	}

	// Initialize all CRT effects when the DOM is ready
	document.addEventListener("DOMContentLoaded", () => {
		const containers = document.querySelectorAll(
			".crt-container, .crt-container-mobile"
		);

		containers.forEach((container) => {
			if (!(container instanceof HTMLElement)) return;
			new CRTEffect(container);
		});
	});
</script>

<style>
	.crt-container,
	.crt-container-mobile {
		position: absolute;
		inset: 0;
		z-index: 5;
		overflow: hidden;
		display: flex;
		align-items: center;
		justify-content: center;
	}
	
	.crt-container canvas,
	.crt-container-mobile canvas {
		width: 100%;
		height: 100%;
		display: block;
	}
</style>
