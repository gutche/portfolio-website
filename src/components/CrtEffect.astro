---
// Props for the component
const { imageUrl, isMobile = false } = Astro.props;
---

<div
	class={isMobile ? "crt-container-mobile" : "crt-container"}
	data-image-url={imageUrl}>
</div>

<script>
	import * as THREE from "three";

	class CRTEffect {
		container: HTMLElement;
		imageUrl: string;
		width: number;
		height: number;
		scene: THREE.Scene = new THREE.Scene();
		camera: THREE.OrthographicCamera = new THREE.OrthographicCamera();
		renderer: THREE.WebGLRenderer = new THREE.WebGLRenderer();
		material: THREE.ShaderMaterial = new THREE.ShaderMaterial();
		constructor(container: HTMLElement, imageUrl: string) {
			this.container = container;
			this.imageUrl = imageUrl;
			this.width = container.offsetWidth;
			this.height = container.offsetHeight;

			this.setupScene();
			this.loadTexture();
			this.animate();
			this.setupResizeListener();
		}

		setupScene() {
			this.scene = new THREE.Scene();
			this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
			this.camera.position.z = 1;

			this.renderer = new THREE.WebGLRenderer({
				antialias: false,
				alpha: true,
				premultipliedAlpha: false,
			});
			this.renderer.setSize(this.width, this.height);
			this.renderer.setPixelRatio(window.devicePixelRatio);
			this.renderer.setClearColor(0x000000, 0);
			this.container.appendChild(this.renderer.domElement);

			const geometry = new THREE.PlaneGeometry(2, 2);
			this.material = new THREE.ShaderMaterial({
				uniforms: {
					tDiffuse: { value: null },
					time: { value: 0.0 },
					sIntensity: { value: 0.1 },
					sCount: { value: 8000 },
					nIntensity: { value: 0.4 },
				},
				transparent: true,
				vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
				fragmentShader: `
          uniform sampler2D tDiffuse;
          uniform float time;
          uniform float sIntensity;
          uniform float sCount;
          uniform float nIntensity;
          varying vec2 vUv;

          float random(vec2 c) {
            return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);
          }

          void main() {
            vec2 uv = vUv;
            vec4 color = texture2D(tDiffuse, uv);
            float scanline = 0.5 + 0.5 * sin(uv.y * sCount - time * 0.5);
            scanline = 1.0 - (scanline * sIntensity);
            color.rgb *= scanline;
            float noise = random(uv + vec2(time * 0.001)) * nIntensity;
            color.rgb += vec3(noise);
            gl_FragColor = color;
          }
        `,
			});

			const plane = new THREE.Mesh(geometry, this.material);
			this.scene.add(plane);
		}

		loadTexture() {
			const loader = new THREE.TextureLoader();
			loader.load(
				this.imageUrl,
				(texture) => {
					texture.premultiplyAlpha = false;
					this.material.uniforms.tDiffuse.value = texture;
					this.container.classList.add("loaded");
				},
				undefined,
				(err) => {
					console.error("Error loading texture:", err);
				}
			);
		}

		animate() {
			requestAnimationFrame(this.animate.bind(this));
			this.material.uniforms.time.value = performance.now() / 1000;
			this.renderer.render(this.scene, this.camera);
		}

		setupResizeListener() {
			window.addEventListener("resize", () => {
				this.width = this.container.offsetWidth;
				this.height = this.container.offsetHeight;

				// For OrthographicCamera, we need to update the frustum instead of aspect
				// This maintains the aspect ratio without stretching
				const aspect = this.width / this.height;

				// Keep the vertical size fixed and adjust horizontal based on aspect ratio
				this.camera.left = -1 * aspect;
				this.camera.right = 1 * aspect;
				// Vertical remains as -1 to 1

				this.camera.updateProjectionMatrix();
				this.renderer.setSize(this.width, this.height);
			});
		}
	}

	// Initialize all CRT effects when the DOM is ready
	document.addEventListener("DOMContentLoaded", () => {
		const containers = document.querySelectorAll(
			".crt-container, .crt-container-mobile"
		);

		containers.forEach((container) => {
			if (!(container instanceof HTMLElement)) return;

			const imageUrl = container.getAttribute("data-image-url");
			if (imageUrl) {
				new CRTEffect(container, imageUrl);
			} else {
				console.error("No image URL provided for CRT effect");
			}
		});
	});
</script>

<style>
	.crt-container {
		position: absolute !important;
		inset: 0 !important;
		width: 100% !important;
		height: 100% !important;
		overflow: hidden;
		background: transparent;
		z-index: 1;
	}

	.crt-container-mobile {
		position: absolute !important;
		inset: 0 !important;
		width: 100% !important;
		height: 100% !important;
		overflow: hidden;
		background: transparent;
		z-index: 1;
	}

	.crt-container::before,
	.crt-container-mobile::before {
		content: "Loading...";
		color: #ffffff;
		opacity: 0.5;
		font-size: 14px;
		position: absolute;
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%);
		transition: opacity 0.3s ease;
		z-index: 2;
	}

	.crt-container.loaded::before,
	.crt-container-mobile.loaded::before {
		opacity: 0;
	}

	.crt-container canvas,
	.crt-container-mobile canvas {
		position: absolute !important;
		inset: 0 !important;
		width: 100% !important;
		height: 100% !important;
		z-index: 1 !important;
		pointer-events: none;
	}
</style>
